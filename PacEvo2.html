<!DOCTYPE html>
<html>
<head>
    <title>Pacman: Evolution 2</title>
    <style>
        body {
            background-color: #000;
            color: #fff;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            height: 100vh;
            margin: 0;
            font-family: 'Press Start 2P', cursive;
        }
        #game-container {
            border: 2px solid #000; /* Border is now handled on canvas */
            line-height: 0;
        }
        #info-header {
            width: 448px;
            display: flex;
            justify-content: space-between;
            font-size: 16px;
            padding-bottom: 10px;
        }
    </style>
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
</head>
<body>
    <div id="info-header">
        <span>Score: <span id="score-display">0</span></span>
        <span>Lives: <span id="lives-display">3</span></span>
    </div>
    <div id="game-container"></div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/matter-js/0.17.1/matter.min.js"></script>
    <script>
        // Game Engine Setup
        const { Engine, Render, Runner, World, Bodies, Body, Events, Common, Vector } = Matter;

        const engine = Engine.create();
        const world = engine.world;
        world.gravity.y = 0;

        // Game constants
        const TILE_SIZE = 16;
        const MAZE_WIDTH_TILES = 28;
        const MAZE_HEIGHT_TILES = 36;
        const GAME_WIDTH = TILE_SIZE * MAZE_WIDTH_TILES;
        const GAME_HEIGHT = TILE_SIZE * MAZE_HEIGHT_TILES;
        const FRAME_TIME_MS = 1000 / 60; // ~16.67ms per frame
        const MAX_SPEED_PER_FRAME = (75.75757625 / 60) * 1.5; // Base speed unit, adjusted for gameplay feel

        // Maze Layout: 0-Path, 1-Wall, 2-Dot, 3-Energizer, 4-Door, 5-House, 6-UI, T-Tunnel, S-Slow Zone
        const mazeLayout = [
            [6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6],[6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6],[6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6],
            [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],[1,2,2,2,2,2,2,2,2,2,2,2,2,1,1,2,2,2,2,2,2,2,2,2,2,2,2,1],[1,3,1,1,1,1,2,1,1,1,1,1,2,1,1,2,1,1,1,1,1,2,1,1,1,1,3,1],
            [1,2,1,1,1,1,2,1,1,1,1,1,2,1,1,2,1,1,1,1,1,2,1,1,1,1,2,1],[1,2,1,1,1,1,2,1,1,1,1,1,2,1,1,2,1,1,1,1,1,2,1,1,1,1,2,1],[1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1],
            [1,2,1,1,1,1,2,1,1,2,1,1,1,1,1,1,1,1,2,1,1,2,1,1,1,1,2,1],[1,2,1,1,1,1,2,1,1,2,1,1,1,1,1,1,1,1,2,1,1,2,1,1,1,1,2,1],[1,2,2,2,2,2,2,1,1,2,2,2,2,1,1,2,2,2,2,1,1,2,2,2,2,2,2,1],
            [1,1,1,1,1,1,2,1,1,1,1,1,0,1,1,0,1,1,1,1,1,2,1,1,1,1,1,1],[1,1,1,1,1,1,2,1,1,1,1,1,0,1,1,0,1,1,1,1,1,2,1,1,1,1,1,1],[1,1,1,1,1,1,2,1,1,0,0,0,0,0,0,0,0,0,0,1,1,2,1,1,1,1,1,1],
            [1,1,1,1,1,1,2,1,1,0,1,1,1,4,4,1,1,1,0,1,1,2,1,1,1,1,1,1],[1,1,1,1,1,1,2,1,1,0,1,5,5,5,5,5,5,1,0,1,1,2,1,1,1,1,1,1],['T','S','S','S',0,0,2,0,0,0,1,5,5,5,5,5,5,1,0,0,0,2,0,0,'S','S','S','T'],
            [1,1,1,1,1,1,2,1,1,0,1,5,5,5,5,5,5,1,0,1,1,2,1,1,1,1,1,1],[1,1,1,1,1,1,2,1,1,0,1,1,1,1,1,1,1,1,0,1,1,2,1,1,1,1,1,1],[1,1,1,1,1,1,2,1,1,0,0,0,0,0,0,0,0,0,0,1,1,2,1,1,1,1,1,1],
            [1,1,1,1,1,1,2,1,1,0,1,1,1,1,1,1,1,1,0,1,1,2,1,1,1,1,1,1],[1,1,1,1,1,1,2,1,1,0,1,1,1,1,1,1,1,1,0,1,1,2,1,1,1,1,1,1],[1,2,2,2,2,2,2,2,2,2,2,2,2,1,1,2,2,2,2,2,2,2,2,2,2,2,2,1],
            [1,2,1,1,1,1,2,1,1,1,1,1,2,1,1,2,1,1,1,1,1,2,1,1,1,1,2,1],[1,3,1,1,1,1,2,1,1,1,1,1,2,1,1,2,1,1,1,1,1,2,1,1,1,1,3,1],[1,2,2,2,1,1,2,2,2,2,2,2,2,0,0,2,2,2,2,2,2,2,1,1,2,2,2,1],
            [1,1,1,2,1,1,2,1,1,2,1,1,1,1,1,1,1,1,2,1,1,2,1,1,2,1,1,1],[1,1,1,2,1,1,2,1,1,2,1,1,1,1,1,1,1,1,2,1,1,2,1,1,2,1,1,1],[1,2,2,2,2,2,2,1,1,2,2,2,2,1,1,2,2,2,2,1,1,2,2,2,2,2,2,1],
            [1,2,1,1,1,1,1,1,1,1,1,1,2,1,1,2,1,1,1,1,1,1,1,1,1,1,2,1],[1,2,1,1,1,1,1,1,1,1,1,1,2,1,1,2,1,1,1,1,1,1,1,1,1,1,2,1],[1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1],
            [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],[6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6],[6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6]
        ];
        
        // Helper Functions (Moved up to prevent initialization errors)
        const getTileCenter = (x, y) => ({ x: x * TILE_SIZE + TILE_SIZE / 2, y: y * TILE_SIZE + TILE_SIZE / 2 });
        const getTileCoords = (pos) => ({ x: Math.floor(pos.x / TILE_SIZE), y: Math.floor(pos.y / TILE_SIZE) });
        const getDistance = (pos1, pos2) => Math.sqrt(Math.pow(pos1.x - pos2.x, 2) + Math.pow(pos1.y - pos2.y, 2));
        const isWall = (x, y) => !mazeLayout[y] || mazeLayout[y][x] === 1 || mazeLayout[y][x] === 4;

        // --- COLLISION CATEGORIES ---
        const collisionCategories = {
            wall: 0x0001,
            ghost: 0x0002,
            pacman: 0x0004,
            dot: 0x0008
        };

        // --- SPEED TABLES ---
        const pacmanSpeedTable = [
            /* Lvl 1   */ { normal: 0.80, fright: 0.90 },
            /* Lvl 2-4 */ { normal: 0.90, fright: 0.95 },
            /* Lvl 5-20*/ { normal: 1.00, fright: 1.00 },
            /* Lvl 21+ */ { normal: 0.90, fright: -1   } // -1 indicates no fright speed
        ];
        const ghostSpeedTable = [
            /* Lvl 1   */ { normal: 0.75, tunnel: 0.40, fright: 0.50 },
            /* Lvl 2-4 */ { normal: 0.85, tunnel: 0.45, fright: 0.55 },
            /* Lvl 5-20*/ { normal: 0.95, tunnel: 0.50, fright: 0.60 },
            /* Lvl 21+ */ { normal: 0.95, tunnel: 0.50, fright: -1   }
        ];

        // Level-specific data
        const levelData = [
            { frightTime: 6000, flashes: 5 }, { frightTime: 5000, flashes: 5 }, { frightTime: 4000, flashes: 5 },
            { frightTime: 3000, flashes: 5 }, { frightTime: 2000, flashes: 5 }, { frightTime: 5000, flashes: 5 },
            { frightTime: 2000, flashes: 5 }, { frightTime: 2000, flashes: 5 }, { frightTime: 1000, flashes: 3 },
            { frightTime: 5000, flashes: 5 }, { frightTime: 2000, flashes: 5 }, { frightTime: 1000, flashes: 3 },
            { frightTime: 1000, flashes: 3 }, { frightTime: 3000, flashes: 5 }, { frightTime: 1000, flashes: 3 },
            { frightTime: 1000, flashes: 3 }, { frightTime: 0, flashes: 0 },    { frightTime: 1000, flashes: 3 },
            { frightTime: 0, flashes: 0 },    { frightTime: 0, flashes: 0 },    { frightTime: 0, flashes: 0 }
        ];

        // Renderer Setup
        const render = Render.create({
            element: document.getElementById('game-container'),
            engine: engine,
            options: {
                width: GAME_WIDTH,
                height: GAME_HEIGHT,
                wireframes: false,
                background: '#000'
            }
        });

        Render.run(render);
        const runner = Runner.create();
        Runner.run(runner, engine);

        // Game State
        let gameState = 'playing'; // playing, dying, gameOver
        let score = 0;
        let lives = 2;
        let level = 1;
        let dots = [];
        let energizers = [];
        let ghosts = {};
        let walls = [];
        let globalDotsEaten = 0;
        let dotsEatenSinceDeath = 0;
        let lifeLost = false;
        let currentMode = 'scatter';
        let previousMode = 'scatter';
        let modeChangeTimer = null;
        let frightenedTimer = null;
        let frightFlashTimer = null;
        let ghostsEatenThisPowerup = 0;
        let pacmanDir = {x: -1, y: 0};
        let requestedDir = {x: -1, y: 0};
        let pacmanPausedFrames = 0;
        let deathAnimation = { active: false, progress: 0, pos: {x:0, y:0} };
        let pacmanTargetPos = getTileCenter(13.5, 26); // The "leash" target

        // --- SPEED CALCULATION ---
        function getSpeed(character) {
            const currentLevel = level;
            const tableIndex = currentLevel === 1 ? 0 : currentLevel >= 2 && currentLevel <= 4 ? 1 : currentLevel >= 5 && currentLevel <= 20 ? 2 : 3;
            
            if (character.label === 'pacman') {
                const speedData = pacmanSpeedTable[tableIndex];
                const multiplier = currentMode === 'frightened' ? speedData.fright : speedData.normal;
                return MAX_SPEED_PER_FRAME * multiplier;
            } else { // It's a ghost
                const speedData = ghostSpeedTable[tableIndex];
                const ghostTile = getTileCoords(character.position);
                const tileType = mazeLayout[ghostTile.y] ? mazeLayout[ghostTile.y][ghostTile.x] : null;

                if (tileType === 'T' || tileType === 'S') {
                    return MAX_SPEED_PER_FRAME * speedData.tunnel;
                }
                if (character.state === 'frightened') {
                    return MAX_SPEED_PER_FRAME * speedData.fright;
                }
                if (character.state === 'eaten') {
                    return MAX_SPEED_PER_FRAME * 2; // Eaten ghosts move faster
                }
                return MAX_SPEED_PER_FRAME * speedData.normal;
            }
        }

        // Create Maze Objects
        for (let y = 0; y < mazeLayout.length; y++) {
            for (let x = 0; x < mazeLayout[y].length; x++) {
                const type = mazeLayout[y][x];
                const pos = getTileCenter(x, y);
                let body;
                if (type === 1) {
                    body = Bodies.rectangle(pos.x, pos.y, TILE_SIZE, TILE_SIZE, { 
                        isStatic: true, 
                        render: { visible: false },
                        collisionFilter: { category: collisionCategories.wall },
                        friction: 0,
                        frictionAir: 0,
                        frictionStatic: 0,
                        restitution: 0
                    });
                    walls.push(body);
                    World.add(world, body);
                } else if (type === 2) {
                    body = Bodies.circle(pos.x, pos.y, TILE_SIZE / 5, { isStatic: true, isSensor: true, label: 'dot', render: { fillStyle: '#FFFFFF' } });
                    dots.push(body);
                    World.add(world, body);
                } else if (type === 3) {
                    body = Bodies.circle(pos.x, pos.y, TILE_SIZE / 2.5, { isStatic: true, isSensor: true, label: 'energizer', render: { fillStyle: '#FFFFFF' } });
                    energizers.push(body);
                    World.add(world, body);
                } else if (type === 4) {
                    body = Bodies.rectangle(pos.x, pos.y, TILE_SIZE, TILE_SIZE/2, { isStatic: true, isSensor: true, label: 'ghost-door', render: { fillStyle: '#FFB8FF' } });
                    World.add(world, body);
                }
            }
        }

        // Create Pacman
        const pacmanStartPos = getTileCenter(13.5, 26);
        const pacman = Bodies.circle(pacmanStartPos.x, pacmanStartPos.y, TILE_SIZE / 2 - 2, { // Slightly smaller radius
            label: 'pacman',
            render: { fillStyle: 'yellow' },
            density: 0.001,
            friction: 0,
            frictionAir: 0,
            frictionStatic: 0,
            restitution: 0,
            collisionFilter: {
                category: collisionCategories.pacman,
                mask: collisionCategories.wall | collisionCategories.ghost | collisionCategories.dot
            }
        });
        World.add(world, pacman);

        // Create Ghosts
        const ghostData = {
            blinky: { color: '#FF0000', startPos: getTileCenter(13.5, 14), scatterTarget: { x: 25, y: 0 } },
            pinky:  { color: '#FFB8FF', startPos: getTileCenter(13.5, 17), scatterTarget: { x: 2, y: 0 } },
            inky:   { color: '#00FFFF', startPos: getTileCenter(11.5, 17), scatterTarget: { x: 27, y: 35 } },
            clyde:  { color: '#FFB851', startPos: getTileCenter(15.5, 17), scatterTarget: { x: 0, y: 35 } }
        };
        const ghostReleaseOrder = ['pinky', 'inky', 'clyde'];
        const ghostReleaseDots = { pinky: 0, inky: 30, clyde: 60 };
        const ghostReleaseDotsAfterDeath = { pinky: 7, inky: 17, clyde: 32 };

        for (const name in ghostData) {
            const data = ghostData[name];
            ghosts[name] = Bodies.circle(data.startPos.x, data.startPos.y, TILE_SIZE / 2 - 2, { // Slightly smaller radius
                label: `ghost-${name}`,
                render: { fillStyle: data.color },
                density: 0.001,
                friction: 0,
                frictionAir: 0,
                frictionStatic: 0,
                restitution: 0,
                collisionFilter: {
                    category: collisionCategories.ghost,
                    mask: collisionCategories.wall | collisionCategories.pacman // Can collide with walls and pacman
                }
            });
            ghosts[name].originalColor = data.color;
            ghosts[name].startPos = data.startPos;
            ghosts[name].targetPos = data.startPos; // Leash target for ghosts
            ghosts[name].state = 'inPen'; // All ghosts start in the pen
            ghosts[name].scatterTarget = data.scatterTarget;
            ghosts[name].targetTile = data.scatterTarget;
            ghosts[name].currentDir = {x: 0, y: -1}; // Default start dir is up
            ghosts[name].modeChangesInPen = 0; // For exit direction logic
            World.add(world, ghosts[name]);
        }

        // --- GHOST AI ---
        function updateGhostAI() {
            for (const name in ghosts) {
                const ghost = ghosts[name];
                const ghostSpeed = getSpeed(ghost);

                // Handle special states first
                if (ghost.state === 'inPen') {
                    const newY = ghost.startPos.y + Math.sin(Date.now() / 250) * 4;
                    Body.setVelocity(ghost, { x: 0, y: (newY - ghost.position.y) * 0.1 });
                    continue; // Skip main logic for inPen state
                }
                
                const distanceToTarget = Vector.magnitude(Vector.sub(ghost.targetPos, ghost.position));

                // --- DECISION LOGIC (runs when ghost reaches its target) ---
                if (distanceToTarget < 1) {
                    Body.setPosition(ghost, ghost.targetPos); // Snap to grid
                    
                    const currentTile = getTileCoords(ghost.targetPos);
                    
                    // State transitions based on reaching targets
                    if (ghost.state === 'leaving') {
                        ghost.state = 'exiting';
                        ghost.targetPos = getTileCenter(13.5, 11);
                        ghost.currentDir = {x: 0, y: -1}; // Move up
                        continue;
                    } else if (ghost.state === 'exiting') {
                        // Decide left or right turn based on mode changes
                        if (ghost.modeChangesInPen > 0) {
                             ghost.currentDir = {x: 1, y: 0}; // Turn Right
                             ghost.targetPos = getTileCenter(currentTile.x + 1, currentTile.y);
                        } else {
                             ghost.currentDir = {x: -1, y: 0}; // Turn Left
                             ghost.targetPos = getTileCenter(currentTile.x - 1, currentTile.y);
                        }
                        ghost.state = 'active';
                        ghost.modeChangesInPen = 0; // Reset counter
                        continue;
                    } else if (ghost.state === 'eaten' && currentTile.y === 11) {
                        // If eaten and at the tile above the door, move down into the house
                        ghost.state = 'entering';
                        ghost.targetPos = getTileCenter(13.5, 14);
                        ghost.currentDir = {x: 0, y: 1};
                        continue;
                    } else if (ghost.state === 'entering') {
                         ghost.state = 'inPen';
                         ghost.collisionFilter.mask = collisionCategories.wall | collisionCategories.pacman; // Restore collision
                         ghost.render.fillStyle = ghost.originalColor;
                         Body.setPosition(ghost, ghost.startPos);
                         ghost.targetPos = ghost.startPos;
                         continue;
                    }

                    // --- Main AI Decision Making ---
                    const possibleDirs = {};
                    if (!isWall(currentTile.x, currentTile.y - 1)) possibleDirs.up = { x: 0, y: -1 };
                    if (!isWall(currentTile.x, currentTile.y + 1)) possibleDirs.down = { x: 0, y: 1 };
                    if (!isWall(currentTile.x - 1, currentTile.y)) possibleDirs.left = { x: -1, y: 0 };
                    if (!isWall(currentTile.x + 1, currentTile.y)) possibleDirs.right = { x: 1, y: 0 };
                    
                    // Ghosts can't go up from specific tiles
                    const isRestrictedZone = (currentTile.y === 14 || currentTile.y === 23) && (currentTile.x >= 11 && currentTile.x <= 16);
                    if (ghost.state !== 'frightened' && isRestrictedZone) {
                        delete possibleDirs.up;
                    }
                    
                    // Prevent non-eaten ghosts from pathfinding into the ghost house entrance
                    if (ghost.state !== 'eaten' && currentTile.y === 11 && (currentTile.x === 13 || currentTile.x === 14)) {
                        delete possibleDirs.down;
                    }


                    // Ghosts can't reverse direction, with an exception for eaten ghosts entering the house
                    const isEatenAtDoor = (ghost.state === 'eaten' && currentTile.y === 11);
                    if (!isEatenAtDoor) {
                        if (ghost.currentDir.x === 1) delete possibleDirs.left;
                        if (ghost.currentDir.x === -1) delete possibleDirs.right;
                        if (ghost.currentDir.y === 1) delete possibleDirs.up;
                        if (ghost.currentDir.y === -1) delete possibleDirs.down;
                    }


                    let bestDirVector = null;
                    if (ghost.state === 'frightened') {
                        const choices = Object.keys(possibleDirs);
                        if (choices.length > 0) {
                           const randomDir = choices[Math.floor(Math.random() * choices.length)];
                           bestDirVector = possibleDirs[randomDir];
                        }
                    } else {
                        if (currentMode === 'chase') ghost.targetTile = getGhostTarget(name);
                        else if (currentMode === 'scatter') ghost.targetTile = ghost.scatterTarget;
                        
                        let minDistance = Infinity;
                        for (const dir in possibleDirs) {
                            const vector = possibleDirs[dir];
                            const nextTile = { x: currentTile.x + vector.x, y: currentTile.y + vector.y };
                            const dist = getDistance(nextTile, ghost.targetTile);
                            if (dist < minDistance) {
                                minDistance = dist;
                                bestDirVector = vector;
                            }
                        }
                    }
                    
                    if (bestDirVector) {
                        ghost.currentDir = bestDirVector;
                        const nextTileCoords = { x: currentTile.x + bestDirVector.x, y: currentTile.y + bestDirVector.y };
                        ghost.targetPos = getTileCenter(nextTileCoords.x, nextTileCoords.y);
                    }
                }
                
                // --- LEASH EXECUTION (runs every frame) ---
                const newDistanceToTarget = Vector.magnitude(Vector.sub(ghost.targetPos, ghost.position));
                if (newDistanceToTarget > 0) {
                    const direction = Vector.normalise(Vector.sub(ghost.targetPos, ghost.position));
                    const velocity = Vector.mult(direction, ghostSpeed);
                    Body.setVelocity(ghost, velocity);
                } else {
                    Body.setVelocity(ghost, {x: 0, y: 0});
                }
            }
        }

        function handleGhostPenStates(ghost, speed) {
            // This function now sets the initial target for a ghost leaving or re-entering the pen
            if (ghost.state === 'leaving') {
                ghost.targetPos = getTileCenter(13.5, 14); // Target the door
            } else if (ghost.state === 'eaten') {
                 ghost.targetPos = getTileCenter(13.5, 11); // Target the tile ABOVE the door to re-enter
            }
        }

        function getGhostTarget(name) {
            const pacmanTile = getTileCoords(pacman.position);
            switch(name) {
                case 'blinky': return pacmanTile;
                case 'pinky':
                    let pinkyTarget = { ...pacmanTile };
                    if (pacmanDir.y === -1) { pinkyTarget.y -= 4; pinkyTarget.x -= 4; } // Up
                    else if (pacmanDir.y === 1) { pinkyTarget.y += 4; } // Down
                    else if (pacmanDir.x === -1) { pinkyTarget.x -= 4; } // Left
                    else if (pacmanDir.x === 1) { pinkyTarget.x += 4; } // Right
                    return pinkyTarget;
                case 'inky':
                    const blinkyTile = getTileCoords(ghosts.blinky.position);
                    let offsetTile = { ...pacmanTile };
                    if (pacmanDir.y === -1) { offsetTile.y -= 2; } // Up
                    else if (pacmanDir.y === 1) { offsetTile.y += 2; } // Down
                    else if (pacmanDir.x === -1) { offsetTile.x -= 2; } // Left
                    else if (pacmanDir.x === 1) { offsetTile.x += 2; } // Right
                    return { x: blinkyTile.x + (offsetTile.x - blinkyTile.x) * 2, y: blinkyTile.y + (offsetTile.y - blinkyTile.y) * 2 };
                case 'clyde':
                    return getDistance(getTileCoords(ghosts.clyde.position), pacmanTile) > 8 ? pacmanTile : ghosts.clyde.scatterTarget;
            }
        }

        const modeTimings = [
            { mode: 'scatter', time: 7000 }, { mode: 'chase', time: 20000 },
            { mode: 'scatter', time: 7000 }, { mode: 'chase', time: 20000 },
            { mode: 'scatter', time: 5000 }, { mode: 'chase', time: 20000 },
            { mode: 'scatter', time: 5000 }, { mode: 'chase', time: Infinity }
        ];
        let modeIndex = 0;

        function setGameMode(mode) {
             if (currentMode === 'frightened') {
                 previousMode = mode;
                 return;
             }
             currentMode = mode;
             // Reverse ghost direction on mode change
             for (const name in ghosts) {
                 const ghost = ghosts[name];
                 if (ghost.state === 'active' || ghost.state === 'frightened') {
                    ghost.currentDir.x *= -1;
                    ghost.currentDir.y *= -1;
                    const currentTile = getTileCoords(ghost.position);
                    const nextTileCoords = { x: currentTile.x + ghost.currentDir.x, y: currentTile.y + ghost.currentDir.y };
                    if(!isWall(nextTileCoords.x, nextTileCoords.y)) {
                        ghost.targetPos = getTileCenter(nextTileCoords.x, nextTileCoords.y);
                    }
                 } else if (ghost.state === 'inPen' || ghost.state === 'exiting') {
                     ghost.modeChangesInPen++;
                 }
             }
        }

        function scheduleNextMode() {
            clearTimeout(modeChangeTimer);
            if (modeIndex >= modeTimings.length) return;
            const current = modeTimings[modeIndex];
            setGameMode(current.mode);
            if (current.time !== Infinity) {
                modeChangeTimer = setTimeout(() => {
                    modeIndex++;
                    scheduleNextMode();
                }, current.time);
            }
        }
        
        function startFrightenedMode() {
            clearTimeout(frightenedTimer);
            clearInterval(frightFlashTimer);
            clearTimeout(modeChangeTimer);
            
            const lvlIndex = Math.min(level - 1, levelData.length - 1);
            const data = levelData[lvlIndex];
            if (data.frightTime === 0) return;

            previousMode = currentMode;
            currentMode = 'frightened';
            ghostsEatenThisPowerup = 0;

            for (const name in ghosts) {
                const ghost = ghosts[name];
                if (ghost.state !== 'eaten') {
                    if (ghost.state !== 'frightened') {
                        ghost.stateBeforeFright = ghost.state;
                    }
                    if (ghost.state === 'active') {
                        // Reverse direction when frightened
                        ghost.currentDir.x *= -1;
                        ghost.currentDir.y *= -1;
                    }
                    ghost.state = 'frightened';
                    ghost.render.fillStyle = '#2121DE';
                }
            }
            
            const flashInterval = 16 * FRAME_TIME_MS;
            const totalFlashes = data.flashes * 2;
            const totalFlashTime = totalFlashes * flashInterval;
            const solidBlueTime = data.frightTime - totalFlashTime;

            frightenedTimer = setTimeout(() => startFlashing(totalFlashes, flashInterval), solidBlueTime > 0 ? solidBlueTime : 0);
        }

        function startFlashing(flashesLeft, interval) {
            frightFlashTimer = setInterval(() => {
                if (flashesLeft <= 0 || currentMode !== 'frightened') {
                    clearInterval(frightFlashTimer);
                    endFrightenedMode();
                    return;
                }
                for (const name in ghosts) {
                    const ghost = ghosts[name];
                    if (ghost.state === 'frightened') {
                        ghost.render.fillStyle = (flashesLeft % 2 === 0) ? '#FFFFFF' : '#2121DE';
                    }
                }
                flashesLeft--;
            }, interval);
        }

        function endFrightenedMode() {
            clearInterval(frightFlashTimer);
            clearTimeout(frightenedTimer);
            if (currentMode !== 'frightened') return;
            currentMode = previousMode;
            for (const name in ghosts) {
                const ghost = ghosts[name];
                if (ghost.state === 'frightened') {
                    ghost.state = ghost.stateBeforeFright || 'active';
                    ghost.render.fillStyle = ghost.originalColor;
                }
            }
            scheduleNextMode();
        }

        function checkGhostRelease() {
            const releaseCounters = lifeLost ? ghostReleaseDotsAfterDeath : ghostReleaseDots;
            const dotCount = lifeLost ? dotsEatenSinceDeath : globalDotsEaten;

            for (const name of ghostReleaseOrder) {
                const ghost = ghosts[name];
                if (ghost.state === 'inPen' && dotCount >= releaseCounters[name]) {
                    ghost.state = 'leaving';
                    handleGhostPenStates(ghost);
                }
            }
        }

        function startDeathSequence() {
            gameState = 'dying';
            deathAnimation.active = true;
            deathAnimation.progress = 0;
            deathAnimation.pos = pacman.position;
            
            for(const name in ghosts) { ghosts[name].render.visible = false; }
            pacman.render.visible = false;

            setTimeout(() => {
                const animationDuration = 124 * FRAME_TIME_MS;
                const startTime = Date.now();
                function animateDeath() {
                    const elapsedTime = Date.now() - startTime;
                    deathAnimation.progress = elapsedTime / animationDuration;
                    if (elapsedTime < animationDuration) {
                        requestAnimationFrame(animateDeath);
                    } else {
                        deathAnimation.active = false;
                        setTimeout(resetAfterDeath, 60 * FRAME_TIME_MS);
                    }
                }
                requestAnimationFrame(animateDeath);
            }, 10 * FRAME_TIME_MS);
        }

        function resetAfterDeath() {
            lives--;
            if (lives < 0) {
                gameState = 'gameOver';
            } else {
                lifeLost = true;
                dotsEatenSinceDeath = 0;
                
                Body.setPosition(pacman, pacmanStartPos);
                pacmanTargetPos = pacmanStartPos; // Reset the leash target
                pacmanDir = {x: -1, y: 0};
                requestedDir = {x: -1, y: 0};
                pacman.render.visible = true;

                for (const name in ghosts) {
                    const ghost = ghosts[name];
                    Body.setPosition(ghost, ghost.startPos);
                    ghost.targetPos = ghost.startPos;
                    ghost.state = 'inPen';
                    ghost.render.visible = true;
                    ghost.render.fillStyle = ghost.originalColor;
                    ghost.collisionFilter.mask = collisionCategories.wall | collisionCategories.pacman;
                    ghost.modeChangesInPen = 0;
                }
                
                // Blinky starts outside the pen, active and ready
                const blinkyStartPos = getTileCenter(13.5, 11);
                Body.setPosition(ghosts.blinky, blinkyStartPos);
                ghosts.blinky.state = 'active';
                ghosts.blinky.targetPos = getTileCenter(12.5, 11);
                ghosts.blinky.currentDir = {x: -1, y: 0};


                modeIndex = 0;
                scheduleNextMode();
                gameState = 'playing';
            }
        }
        
        document.addEventListener('keydown', (event) => {
            if (gameState !== 'playing') return;
            switch (event.key) {
                case 'ArrowUp': requestedDir = { x: 0, y: -1 }; break;
                case 'ArrowDown': requestedDir = { x: 0, y: 1 }; break;
                case 'ArrowLeft': requestedDir = { x: -1, y: 0 }; break;
                case 'ArrowRight': requestedDir = { x: 1, y: 0 }; break;
            }
        });

        function updatePacmanMovement() {
            if (pacmanPausedFrames > 0) {
                Body.setVelocity(pacman, { x: 0, y: 0 });
                return;
            }

            const pacmanSpeed = getSpeed(pacman);
            const distanceToTarget = Vector.magnitude(Vector.sub(pacmanTargetPos, pacman.position));

            // Check if Pac-Man is at or very near its target tile
            if (distanceToTarget < 1) {
                // Snap to the target position to correct any drift
                Body.setPosition(pacman, pacmanTargetPos);
                Body.setVelocity(pacman, { x: 0, y: 0 });

                const currentTile = getTileCoords(pacmanTargetPos);

                // --- Turn Buffering Logic ---
                // First, check if the player's requested direction is a valid move
                const nextTileInRequestedDir = { x: currentTile.x + requestedDir.x, y: currentTile.y + requestedDir.y };
                if ((requestedDir.x !== 0 || requestedDir.y !== 0) && !isWall(nextTileInRequestedDir.x, nextTileInRequestedDir.y)) {
                    // Valid turn requested, so update the current direction and the new target
                    pacmanDir = { ...requestedDir };
                    pacmanTargetPos = getTileCenter(nextTileInRequestedDir.x, nextTileInRequestedDir.y);
                } else {
                    // If requested turn is not valid, check if we can continue in the current direction
                    const nextTileInCurrentDir = { x: currentTile.x + pacmanDir.x, y: currentTile.y + pacmanDir.y };
                    if (!isWall(nextTileInCurrentDir.x, nextTileInCurrentDir.y)) {
                        // Continue in the same direction
                        pacmanTargetPos = getTileCenter(nextTileInCurrentDir.x, nextTileInCurrentDir.y);
                    }
                    // If both are blocked, Pac-Man will simply stop at the target.
                }
            }
            
            // --- Leash/Attractor Logic ---
            // This part runs every frame as long as Pac-Man is not at its target
            // It continuously pulls Pac-Man towards its current target tile
            const newDistanceToTarget = Vector.magnitude(Vector.sub(pacmanTargetPos, pacman.position));
            if (newDistanceToTarget > 0) {
                 const direction = Vector.normalise(Vector.sub(pacmanTargetPos, pacman.position));
                 const velocity = Vector.mult(direction, pacmanSpeed);
                 Body.setVelocity(pacman, velocity);
            }
        }


        Events.on(engine, 'beforeUpdate', (event) => {
            if (gameState !== 'playing') {
                 Body.setVelocity(pacman, {x:0, y:0});
                 for(const name in ghosts) { Body.setVelocity(ghosts[name], {x:0, y:0}); }
                 return;
            }

            if (pacmanPausedFrames > 0) {
                pacmanPausedFrames--;
                Body.setVelocity(pacman, {x:0, y:0});
            } else {
                updatePacmanMovement();
            }
            
            const pacmanTile = getTileCoords(pacman.position);
            if (pacmanTile.x <= 0 && pacmanTile.y === 17) {
                const newPos = {x: GAME_WIDTH - TILE_SIZE * 1.5, y: pacman.position.y};
                Body.setPosition(pacman, newPos);
                pacmanTargetPos = newPos;
            }
            else if (pacmanTile.x >= MAZE_WIDTH_TILES - 1 && pacmanTile.y === 17) {
                const newPos = {x: TILE_SIZE * 1.5, y: pacman.position.y};
                Body.setPosition(pacman, newPos);
                pacmanTargetPos = newPos;
            }

            updateGhostAI();
        });

        Events.on(engine, 'collisionStart', (event) => {
            if (gameState !== 'playing') return;
            const pairs = event.pairs;
            for (let i = 0; i < pairs.length; i++) {
                const pair = pairs[i];
                const bodyA = pair.bodyA;
                const bodyB = pair.bodyB;

                const isPacmanInvolved = bodyA.label === 'pacman' || bodyB.label === 'pacman';
                if (!isPacmanInvolved) continue;

                const otherBody = bodyA.label === 'pacman' ? bodyB : bodyA;

                if (otherBody.label === 'dot') {
                    pacmanPausedFrames = 1;
                    score += 10;
                    globalDotsEaten++;
                    if(lifeLost) dotsEatenSinceDeath++;
                    checkGhostRelease();
                    World.remove(world, otherBody);
                } else if (otherBody.label === 'energizer') {
                    pacmanPausedFrames = 3;
                    score += 50;
                    startFrightenedMode();
                    World.remove(world, otherBody);
                } else if (otherBody.label.startsWith('ghost-')) {
                    const ghost = Object.values(ghosts).find(g => g.id === otherBody.id);
                    if (ghost.state === 'frightened') {
                        ghostsEatenThisPowerup++;
                        score += Math.pow(2, ghostsEatenThisPowerup) * 100;
                        ghost.state = 'eaten';
                        ghost.collisionFilter.mask = collisionCategories.wall; // Eaten ghosts only collide with walls
                        ghost.render.fillStyle = '#FFFFFF';
                        handleGhostPenStates(ghost);
                    } else if (ghost.state === 'active' || ghost.state === 'leaving' || ghost.state === 'exiting') {
                        startDeathSequence();
                    }
                }
            }
        });
        
        Events.on(render, 'afterRender', () => {
            const context = render.context;
            context.beginPath();
            for (let y = 0; y < mazeLayout.length; y++) {
                for (let x = 0; x < mazeLayout[y].length; x++) {
                    if (mazeLayout[y][x] === 1) {
                         context.rect(x * TILE_SIZE, y * TILE_SIZE, TILE_SIZE, TILE_SIZE);
                    }
                }
            }
            context.fillStyle = '#0000FF';
            context.fill();
            
            context.font = "16px 'Press Start 2P'";
            context.fillStyle = "white";
            context.textAlign = "left";
            context.fillText("1UP", TILE_SIZE, TILE_SIZE * 2);
            context.fillText(score.toString(), TILE_SIZE, TILE_SIZE * 3);
            context.textAlign = "center";
            context.fillText("HIGH SCORE", GAME_WIDTH / 2, TILE_SIZE * 2);
            context.fillText("3333360", GAME_WIDTH / 2, TILE_SIZE * 3);

            if (deathAnimation.active) {
                const p = deathAnimation.progress;
                const radius = (TILE_SIZE / 2) * (1 - p);
                const angle = 0.25 * Math.PI + (1.5 * Math.PI * p);
                context.beginPath();
                context.arc(deathAnimation.pos.x, deathAnimation.pos.y, radius, angle, 2 * Math.PI - angle);
                context.lineTo(deathAnimation.pos.x, deathAnimation.pos.y);
                context.closePath();
                context.fillStyle = 'yellow';
                context.fill();
            }

            if (gameState === 'gameOver') {
                context.fillStyle = 'rgba(0, 0, 0, 0.5)';
                context.fillRect(0, 0, GAME_WIDTH, GAME_HEIGHT);
                context.fillStyle = 'red';
                context.textAlign = 'center';
                context.fillText('GAME OVER', GAME_WIDTH / 2, GAME_HEIGHT / 2);
            }

            for (let i = 0; i < lives; i++) {
                const lifePos = getTileCenter(2 + (i * 2), 34.5);
                context.beginPath();
                context.arc(lifePos.x, lifePos.y, TILE_SIZE / 2, 0.25 * Math.PI, 1.75 * Math.PI, false);
                context.lineTo(lifePos.x, lifePos.y);
                context.closePath();
                context.fillStyle = 'yellow';
                context.fill();
            }
            const fruitPos = getTileCenter(25, 34.5);
            context.beginPath();
            context.arc(fruitPos.x - 4, fruitPos.y, 5, 0, 2 * Math.PI);
            context.arc(fruitPos.x + 4, fruitPos.y - 2, 5, 0, 2 * Math.PI);
            context.fillStyle = 'red';
            context.fill();
            context.beginPath();
            context.moveTo(fruitPos.x, fruitPos.y - 4);
            context.lineTo(fruitPos.x + 8, fruitPos.y - 12);
            context.strokeStyle = 'green';
            context.lineWidth = 2;
            context.stroke();
        });

        // Start the game
        function initGame() {
            // Set Blinky's initial state to be outside the pen and active
            const blinkyStartPos = getTileCenter(13.5, 11);
            Body.setPosition(ghosts.blinky, blinkyStartPos);
            ghosts.blinky.state = 'active';
            ghosts.blinky.targetPos = getTileCenter(12.5, 11); // Start by moving left
            ghosts.blinky.currentDir = {x: -1, y: 0};
            
            checkGhostRelease();
            scheduleNextMode();
        }

        initGame();

    </script>
</body>
</html>
